{
  parserClass="org.strangeway.jdl.parser.JdlParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Jdl"
  psiImplClassSuffix="Impl"
  psiPackage="org.strangeway.jdl.psi"
  psiImplPackage="org.strangeway.jdl.psi.impl"

  elementTypeHolderClass="org.strangeway.jdl.psi.JdlTokenTypes"
  elementTypeClass="org.strangeway.jdl.psi.JdlElementType"
  tokenTypeClass="org.strangeway.jdl.psi.JdlTokenType"
  psiImplUtilClass="org.strangeway.jdl.psi.JdlPsiUtils"
  tokens = [
    LINE_COMMENT='regexp://.*'
    BLOCK_COMMENT='regexp:/\*([^*]|\*+[^*/])*(\*+/)?'
    LBRACE='{'
    RBRACE='}'
    LBRACKET='['
    RBRACKET=']'
    LPARENTH='('
    RPARENTH=')'
    COMMA=','
    COLON=':'
    TRUE='true'
    FALSE='false'
    WILDCARD='*'
    STRUDEL='@'
    ASSIGN='='
    NEWLINE='regexp:/\r\n|[\r\n]'

    APPLICATION_KEYWORD='application'
    CONFIG_KEYWORD='config'
    ENTITIES_KEYWORD='entities'
    ENTITY_KEYWORD='entity'
    ENUM_KEYWORD='enum'
    DTO_KEYWORD='dto'
    PAGINATE_KEYWORD='paginate'
    SERVICE_KEYWORD='service'
    WITH_KEYWORD='with'
    EXCEPT_KEYWORD='except'
    DEPLOYMENT_KEYWORD='deployment'
    RELATIONSHIP_KEYWORD='relationship'
    TO_KEYWORD='to'
    MICROSERVICE_KEYWORD='microservice'
  ]
}

root ::= (NEWLINE | applicationBlock | entityBlock | enumBlock | relationshipBlock
          | deploymentBlock | constantOption | configurationOption)*

applicationBlock ::= APPLICATION_KEYWORD NEWLINE* LBRACE NEWLINE* applicationContent NEWLINE* RBRACE {
    pin = 1
}

private applicationContent ::= (NEWLINE | configBlock | configurationOption)*

configBlock ::= CONFIG_KEYWORD NEWLINE* LBRACE (NEWLINE | configElement)* RBRACE {
    pin = 1
}

private configElement ::= optionNameValue (COMMA|&NEWLINE) {
    pin = 1
    recoverWhile = notRBraceOrNextOption
}

optionNameValue ::= optionName value? {
    pin = 1
    name = "option"
}

optionName ::= IDENTIFIER {
    name="option name"
}

value ::= id | booleanLiteral | stringLiteral | numberLiteral | arrayLiteral | regexLiteral

exceptEntities ::= EXCEPT_KEYWORD entitiesList {
    pin = 1
}

entitiesList ::= id (COMMA id)*

private withOption ::= WITH_KEYWORD withOptionValue {
    pin = 1
}

withOptionValue ::= IDENTIFIER

constantOption ::= IDENTIFIER ASSIGN constantValue {
    pin = 2
}

constantValue ::= booleanLiteral | stringLiteral | numberLiteral

configurationOption ::= configurationOptionName (wildcardLiteral | entitiesList) withOption? exceptEntities? {
    pin = 1
}

configurationOptionName ::= IDENTIFIER {
    name = "configuration option"
}

wildcardLiteral ::= WILDCARD {
    name = "*"
}

entityBlock ::= ENTITY_KEYWORD NEWLINE* entityId NEWLINE* entityTableDeclaration? NEWLINE* LBRACE (NEWLINE | entityElement)* RBRACE {
    pin = 1
}

entityId ::= IDENTIFIER {
    name = "entity identifier"
}

private entityTableDeclaration ::= LPARENTH NEWLINE* entityTableName NEWLINE* RPARENTH {
    pin = 1
}

entityTableName ::= IDENTIFIER {
    name = "table name"
}

private entityElement ::= entityFieldMapping (COMMA|&NEWLINE) {
    pin = 1
    recoverWhile = notRBraceOrNextOption
}

entityFieldMapping ::= fieldName fieldType fieldConstraint* {
    pin = 1
}

fieldConstraint ::= IDENTIFIER fieldConstraintParameters?

fieldConstraintParameters ::= LPARENTH fieldConstraintParameterValue* RPARENTH {
    pin = 1
}

private fieldConstraintParameterValue ::= value (COMMA|&RPARENTH) {
    pin = 1
    recoverWhile = notRParenthOrNextValue
}

enumBlock ::= ENUM_KEYWORD NEWLINE* enumId NEWLINE* LBRACE (NEWLINE | enumElement)* RBRACE {
    pin = 1
}

enumId ::= IDENTIFIER {
    name = "enum name"
}

private enumElement ::= enumValue (COMMA|&NEWLINE) {
    pin = 1
    recoverWhile = notRBraceOrNextOption
}

enumValue ::= enumKey explicitEnumMapping? {
    pin = 1
}

explicitEnumMapping ::= LPARENTH (IDENTIFIER | stringLiteral) RPARENTH {
    pin = 1
}

enumKey ::= IDENTIFIER {
    name = "enum key"
}

fieldName ::= IDENTIFIER {
    name = "field name"
}

fieldType ::= IDENTIFIER {
    name = "field type"
}

id ::= IDENTIFIER {
    name = "identifier"
}

relationshipBlock ::= RELATIONSHIP_KEYWORD relationshipType NEWLINE* LBRACE (NEWLINE | relationshipElement)* RBRACE {
    pin = 1
}

relationshipType ::= IDENTIFIER

private relationshipElement ::= relationshipMapping (COMMA|&NEWLINE) {
    pin = 1
    recoverWhile = notRBraceOrNextOption
}

relationshipMapping ::= relationshipEntity NEWLINE* TO_KEYWORD NEWLINE* relationshipEntity withOption? {
    pin = 1
}

relationshipEntity ::= id relationshipDetails? {
    pin = 1
}

relationshipDetails ::= LBRACE fieldName (LPARENTH fieldName RPARENTH)? fieldConstraint? RBRACE

deploymentBlock ::= DEPLOYMENT_KEYWORD NEWLINE* LBRACE (NEWLINE | optionNameValue)* RBRACE {
    pin = 1
}

booleanLiteral ::= TRUE | FALSE
numberLiteral ::= DOUBLE_NUMBER | INTEGER_NUMBER
stringLiteral ::= DOUBLE_QUOTED_STRING
arrayLiteral ::= LBRACKET (arrayElement | NEWLINE)* RBRACKET {
    pin = 1
}

private arrayElement ::= value (COMMA|&RBRACKET) {
    pin = 1
    recoverWhile = notBracketOrNextValue
}

private notBracketOrNextValue ::= !(RBRACKET|value)
private notRParenthOrNextValue ::= !(RPARENTH|value)
private notRBraceOrNextOption ::= !(RBRACE|NEWLINE|IDENTIFIER)

regexLiteral ::= REGEX_STRING {
    name = "regex literal"
}