{
  parserClass="org.strangeway.jdl.parser.JdlParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Jdl"
  psiImplClassSuffix="Impl"
  psiPackage="org.strangeway.jdl.psi"
  psiImplPackage="org.strangeway.jdl.psi.impl"

  elementTypeHolderClass="org.strangeway.jdl.psi.JdlTokenTypes"
  elementTypeClass="org.strangeway.jdl.psi.JdlElementType"
  tokenTypeClass="org.strangeway.jdl.psi.JdlTokenType"
  tokens = [
    LINE_COMMENT='regexp://.*'
    BLOCK_COMMENT='regexp:/\*([^*]|\*+[^*/])*(\*+/)?'
    LBRACE='{'
    RBRACE='}'
    LBRACKET='['
    RBRACKET=']'
    LPARENTH='('
    RPARENTH=')'
    COMMA=','
    COLON=':'
    TRUE='true'
    FALSE='false'
    WILDCARD='*'
    STRUDEL='@'

    APPLICATION_KEYWORD='application'
    CONFIG_KEYWORD='config'
    ENTITIES_KEYWORD='entities'
    ENTITY_KEYWORD='entity'
    ENUM_KEYWORD='enum'
    DTO_KEYWORD='dto'
    PAGINATE_KEYWORD='paginate'
    SERVICE_KEYWORD='service'
    WITH_KEYWORD='with'
    EXCEPT_KEYWORD='except'
    DEPLOYMENT_KEYWORD='deployment'
    RELATIONSHIP_KEYWORD='relationship'
    TO_KEYWORD='to'
  ]
}

root ::= (NEWLINE | applicationBlock | entityBlock | enumBlock | relationshipBlock | deploymentBlock | paginateOption | dtoOption | serviceOption)*

applicationBlock ::= APPLICATION_KEYWORD LBRACE NEWLINE* applicationContent NEWLINE* RBRACE {
    pin = 1
}

private applicationContent ::= configBlock (NEWLINE | entitiesOption | dtoOption | paginateOption | serviceOption)*

configBlock ::= CONFIG_KEYWORD LBRACE (NEWLINE | optionNameValue)* RBRACE {
    pin = 1
}

optionNameValue ::= optionName value? (COMMA | NEWLINE) {
    pin = 1
    name = "option"
}

optionName ::= IDENTIFIER {
    name="option name"
}

value ::= id | booleanLiteral | stringLiteral | numberLiteral | arrayLiteral | patternCall

entitiesOption ::= ENTITIES_KEYWORD (wildcardLiteral | entitiesList) exceptEntities? {
    pin = 1
}

exceptEntities ::= EXCEPT_KEYWORD entitiesList {
    pin = 1
}

entitiesList ::= entityId (COMMA entityId)*

entityId ::= IDENTIFIER {
    name = "entity identifier"
}

dtoOption ::= DTO_KEYWORD WILDCARD withOption? {
    pin = 1
}

private withOption ::= WITH_KEYWORD withOptionValue {
    pin = 1
}

withOptionValue ::= IDENTIFIER

paginateOption ::= PAGINATE_KEYWORD (wildcardLiteral | entitiesList) withOption? exceptEntities? {
    pin = 1
}

serviceOption ::= SERVICE_KEYWORD (wildcardLiteral | entitiesList) withOption? exceptEntities? {
    pin = 1
}

entityBlock ::= ENTITY_KEYWORD id (LPARENTH entityTableName RPARENTH)? entityFields? {
    pin = 1
}

wildcardLiteral ::= WILDCARD {
    name = "*"
}

entityTableName ::= IDENTIFIER {
    name = "table name"
}

private entityFields ::= LBRACE (entityFieldMapping | NEWLINE)* RBRACE {
    pin = 1
}

entityFieldMapping ::= fieldName fieldType fieldConstraint* (COMMA | NEWLINE) {
    pin = 1
}

fieldConstraint ::= IDENTIFIER fieldConstraintParameters?

fieldConstraintParameters ::= LPARENTH fieldConstraintParameterValue* RPARENTH {
    pin = 1
}

private fieldConstraintParameterValue ::= value (COMMA|&RPARENTH) {
    pin = 1
    recoverWhile = notRParenthOrNextValue
}

enumBlock ::= ENUM_KEYWORD id LBRACE (enumValue | NEWLINE)* RBRACE {
    pin = 1
}

enumValue ::= enumKey explicitEnumMapping? (COMMA | NEWLINE) {
    pin = 1
}

explicitEnumMapping ::= LPARENTH (IDENTIFIER | stringLiteral) RPARENTH {
    pin = 1
}

enumKey ::= IDENTIFIER {
    name = "enum key"
}

fieldName ::= IDENTIFIER {
    name = "field name"
}

fieldType ::= IDENTIFIER {
    name = "field type"
}

id ::= IDENTIFIER {
    name = "identifier"
}

relationshipBlock ::= RELATIONSHIP_KEYWORD relationshipType LBRACE (NEWLINE | relationshipMapping)* RBRACE {
    pin = 1
}

relationshipType ::= IDENTIFIER

relationshipMapping ::= entityId TO_KEYWORD entityId withOption? (COMMA | NEWLINE)

deploymentBlock ::= DEPLOYMENT_KEYWORD LBRACE optionNameValue* RBRACE {
    pin = 1
}

booleanLiteral ::= TRUE | FALSE
numberLiteral ::= DOUBLE_NUMBER | INTEGER_NUMBER
stringLiteral ::= DOUBLE_QUOTED_STRING
arrayLiteral ::= LBRACKET arrayElement* RBRACKET {
    pin = 1
}

private arrayElement ::= value (COMMA|&RBRACKET) {
    pin = 1
    recoverWhile = notBracketOrNextValue
}

private notBracketOrNextValue ::= !(RBRACKET|value)
private notRParenthOrNextValue ::= !(RPARENTH|value)
private notNewlineOrNextValue ::= !(NEWLINE|value)

patternCall ::= 'pattern' LPARENTH regexLiteral RPARENTH

regexLiteral ::= REGEX_STRING {
    name = "regex literal"
}