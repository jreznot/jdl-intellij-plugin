{
  parserClass="org.strangeway.jdl.parser.JdlParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Jdl"
  psiImplClassSuffix="Impl"
  psiPackage="org.strangeway.jdl.psi"
  psiImplPackage="org.strangeway.jdl.psi.impl"

  elementTypeHolderClass="org.strangeway.jdl.psi.JdlTokenTypes"
  elementTypeClass="org.strangeway.jdl.psi.JdlElementType"
  tokenTypeClass="org.strangeway.jdl.psi.JdlTokenType"
  tokens = [
    LINE_COMMENT='regexp://.*'
    BLOCK_COMMENT='regexp:/\*([^*]|\*+[^*/])*(\*+/)?'
    LBRACE='{'
    RBRACE='}'
    LBRACKET='['
    RBRACKET=']'
    LPARENTH='('
    RPARENTH=')'
    COMMA=','
    COLON=':'
    TRUE='true'
    FALSE='false'
    WILDCARD='*'
    STRUDEL='@'
    ASSIGN='='
    NEWLINE='regexp:/\r\n|[\r\n]'

    APPLICATION_KEYWORD='application'
    CONFIG_KEYWORD='config'
    ENTITIES_KEYWORD='entities'
    ENTITY_KEYWORD='entity'
    ENUM_KEYWORD='enum'
    DTO_KEYWORD='dto'
    PAGINATE_KEYWORD='paginate'
    SERVICE_KEYWORD='service'
    WITH_KEYWORD='with'
    EXCEPT_KEYWORD='except'
    DEPLOYMENT_KEYWORD='deployment'
    RELATIONSHIP_KEYWORD='relationship'
    TO_KEYWORD='to'
    MICROSERVICE_KEYWORD='microservice'
  ]
}

root ::= (NEWLINE | applicationBlock | entityBlock | enumBlock | relationshipBlock
          | deploymentBlock | constantOption | configurationOption)*

applicationBlock ::= APPLICATION_KEYWORD NEWLINE* LBRACE NEWLINE* applicationContent NEWLINE* RBRACE {
    pin = 1
}

private applicationContent ::= configBlock (NEWLINE | configurationOption)*

configBlock ::= CONFIG_KEYWORD NEWLINE* LBRACE (NEWLINE | optionNameValue)* RBRACE {
    pin = 1
}

optionNameValue ::= optionName value? (COMMA | NEWLINE) {
    pin = 1
    name = "option"
}

optionName ::= IDENTIFIER {
    name="option name"
}

value ::= id | booleanLiteral | stringLiteral | numberLiteral | arrayLiteral | regexLiteral

exceptEntities ::= EXCEPT_KEYWORD entitiesList {
    pin = 1
}

entitiesList ::= entityId (COMMA entityId)*

entityId ::= IDENTIFIER {
    name = "entity identifier"
}

private withOption ::= WITH_KEYWORD withOptionValue {
    pin = 1
}

withOptionValue ::= IDENTIFIER

constantOption ::= IDENTIFIER ASSIGN value {
    pin = 2
}

configurationOption ::= configurationOptionName (wildcardLiteral | entitiesList) withOption? exceptEntities? {
    pin = 1
}

configurationOptionName ::= IDENTIFIER {
    name = "configuration option"
}

entityBlock ::= ENTITY_KEYWORD NEWLINE* id NEWLINE* (LPARENTH NEWLINE* entityTableName NEWLINE* RPARENTH)? entityFields? {
    pin = 1
}

wildcardLiteral ::= WILDCARD {
    name = "*"
}

entityTableName ::= IDENTIFIER {
    name = "table name"
}

private entityFields ::= LBRACE (entityFieldMapping | NEWLINE)* RBRACE {
    pin = 1
}

entityFieldMapping ::= fieldName fieldType fieldConstraint* (COMMA | NEWLINE) {
    pin = 1
}

fieldConstraint ::= IDENTIFIER fieldConstraintParameters?

fieldConstraintParameters ::= LPARENTH fieldConstraintParameterValue* RPARENTH {
    pin = 1
}

private fieldConstraintParameterValue ::= value (COMMA|&RPARENTH) {
    pin = 1
    recoverWhile = notRParenthOrNextValue
}

enumBlock ::= ENUM_KEYWORD NEWLINE* id NEWLINE* LBRACE (enumValue | NEWLINE)* RBRACE {
    pin = 1
}

enumValue ::= enumKey explicitEnumMapping? (COMMA | NEWLINE) {
    pin = 1
}

explicitEnumMapping ::= LPARENTH (IDENTIFIER | stringLiteral) RPARENTH {
    pin = 1
}

enumKey ::= IDENTIFIER {
    name = "enum key"
}

fieldName ::= IDENTIFIER {
    name = "field name"
}

fieldType ::= IDENTIFIER {
    name = "field type"
}

id ::= IDENTIFIER {
    name = "identifier"
}

relationshipBlock ::= RELATIONSHIP_KEYWORD relationshipType NEWLINE* LBRACE (NEWLINE | relationshipMapping)* RBRACE {
    pin = 1
}

relationshipType ::= IDENTIFIER

relationshipMapping ::= relationshipEntity TO_KEYWORD relationshipEntity withOption? (COMMA | NEWLINE)

relationshipEntity ::= entityId relationshipDetails?

relationshipDetails ::= LBRACE fieldName (LPARENTH fieldName RPARENTH)? fieldConstraint? RBRACE

deploymentBlock ::= DEPLOYMENT_KEYWORD NEWLINE* LBRACE (optionNameValue | NEWLINE)* RBRACE {
    pin = 1
}

booleanLiteral ::= TRUE | FALSE
numberLiteral ::= DOUBLE_NUMBER | INTEGER_NUMBER
stringLiteral ::= DOUBLE_QUOTED_STRING
arrayLiteral ::= LBRACKET (arrayElement | NEWLINE)* RBRACKET {
    pin = 1
}

private arrayElement ::= value (COMMA|&RBRACKET) {
    pin = 1
    recoverWhile = notBracketOrNextValue
}

private notBracketOrNextValue ::= !(RBRACKET|value)
private notRParenthOrNextValue ::= !(RPARENTH|value)

regexLiteral ::= REGEX_STRING {
    name = "regex literal"
}